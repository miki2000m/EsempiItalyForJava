RIEPILOGO SUI TIPI DI DATO IN JAVA

In Java, i tipi di dato si dividono in due categorie principali: **Tipi Primitivi** e **Tipi Riferimento (Reference Types)**.

--- 1. TIPI PRIMITIVI (PRIMITIVE TYPES) ---

I tipi primitivi sono i mattoni fondamentali del linguaggio. Memorizzano direttamente il valore del dato e non sono oggetti.

Esistono 8 tipi primitivi in Java:

**- Tipi Numerici Interi:**
  - `byte`: 8 bit. Valori da -128 a 127.
  - `short`: 16 bit. Valori da -32,768 a 32,767.
  - `int`: 32 bit. Il tipo intero più usato.
  - `long`: 64 bit. Per numeri interi molto grandi (richiede il suffisso `L`).

**- Tipi Numerici a Virgola Mobile (Floating-Point):**
  - `float`: 32 bit. Precisione singola (richiede il suffisso `f`).
  - `double`: 64 bit. Precisione doppia. È il tipo di default per i valori decimali.

**- Tipo Carattere:**
  - `char`: 16 bit. Rappresenta un singolo carattere Unicode (es. `'A'`).

**- Tipo Booleano:**
  - `boolean`: Rappresenta un valore logico. Può essere solo `true` o `false`.

**Caratteristiche dei Tipi Primitivi:**
- Sono veloci e occupano poca memoria.
- Non sono oggetti, quindi non hanno metodi e non possono essere `null`.

--- 2. TIPI RIFERIMENTO (REFERENCE TYPES) ---

Un tipo riferimento non memorizza direttamente il valore, ma un **riferimento (o indirizzo di memoria)** all'oggetto che contiene i dati.

**Esempi:**
- Tutte le classi (`String`, `ArrayList`, `Scanner`, e quelle create da te).
- Gli Array (`int[]`, `String[]`, ecc.).

**Caratteristiche dei Tipi Riferimento:**
- Una variabile di tipo riferimento può avere il valore `null`.
- Hanno metodi che possono essere invocati su di essi.

--- 3. WRAPPER CLASSES (CLASSI INVOLUCRO) ---

Per ogni tipo primitivo, Java fornisce una corrispondente **classe "involucro" (wrapper)** che lo rappresenta come un oggetto.

| Primitivo | Wrapper     |
|-----------|-------------|
| `boolean` | `Boolean`   |
| `char`    | `Character` |
| `int`     | `Integer`   |
| `double`  | `Double`    |
| ... e così via ... |

**Perché esistono?**
- Per usare i tipi primitivi in contesti che richiedono oggetti, come le **collezioni generiche** (es. `ArrayList<Integer>`).
- Forniscono metodi di utilità (es. `Integer.parseInt("123")`).

**Autoboxing e Unboxing:**
Java esegue automaticamente la conversione tra tipi primitivi e le loro wrapper classes.
- **Autoboxing:** da primitivo a wrapper (`Integer i = 100;`).
- **Unboxing:** da wrapper a primitivo (`int n = i;`).

--- 4. `var` - LOCAL VARIABLE TYPE INFERENCE (DA JAVA 10) ---

La keyword `var` è una scorciatoia sintattica per dichiarare le **variabili locali**. Permette al compilatore di **inferire (capire) il tipo** della variabile dal valore con cui viene inizializzata.

**NON è un tipo dinamico.** Il tipo della variabile viene fissato al momento della compilazione e non può più cambiare.

**Esempio:**
`// Dichiarazione tradizionale`
`String testo = "Ciao";`
`HashMap<String, Integer> mappa = new HashMap<>();`

`// Con var (più conciso)`
`var testoConVar = "Ciao"; // Il compilatore capisce che è una String`
`var mappaConVar = new HashMap<String, Integer>(); // Il compilatore capisce che è una HashMap<String, Integer>`

**Vantaggi:**
- **Leggibilità:** Riduce il codice ripetitivo ("boilerplate"), specialmente con tipi generici complessi, rendendo il codice più pulito.
- **Manutenibilità:** Se il tipo di un'espressione cambia (es. un metodo che prima restituiva `ArrayList` ora restituisce `List`), il codice che usa `var` potrebbe non aver bisogno di modifiche.

**Regole e Limitazioni Fondamentali:**
1.  **Solo per Variabili Locali:** `var` può essere usato solo per variabili all'interno di metodi, costruttori o blocchi di inizializzazione. Non può essere usato per campi di una classe, parametri di metodi o tipi di ritorno.
2.  **Inizializzazione Obbligatoria:** Una variabile dichiarata con `var` deve essere inizializzata sulla stessa riga, altrimenti il compilatore non può inferire il tipo.
    `var nome; // ERRORE!`
3.  **No a `null`:** Non si può inizializzare una variabile `var` con `null`, perché il tipo sarebbe ambiguo.
    `var x = null; // ERRORE!`
4.  **No con Espressioni Lambda:** Non si può usare `var` per dichiarare una lambda senza specificare esplicitamente l'interfaccia funzionale, perché il compilatore non saprebbe a quale interfaccia assegnarla.
    `var fn = () -> {}; // ERRORE!`
    `Runnable fn = () -> {}; // CORRETTO`
