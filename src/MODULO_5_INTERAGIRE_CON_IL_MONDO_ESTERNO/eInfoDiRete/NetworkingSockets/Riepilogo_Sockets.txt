RIEPILOGO SULLA PROGRAMMAZIONE DI RETE CON SOCKETS

La programmazione di rete permette a due o più computer di comunicare tra loro. Il modello più comune per questa comunicazione è il **modello Client-Server**, basato sui **Socket**.

--- CONCETTI FONDAMENTALI ---

1.  **Indirizzo IP:** È l'indirizzo numerico univoco che identifica un computer su una rete (es. `192.168.1.10`).
    - **`localhost` (o `127.0.0.1`):** È un indirizzo speciale che si riferisce sempre alla **stessa macchina** su cui il programma è in esecuzione. È usato per testare client e server sullo stesso computer.

2.  **Porta (Port):** È un numero (da 0 a 65535) che identifica un'applicazione o un servizio specifico in esecuzione su un computer. Se l'indirizzo IP è l'indirizzo di un palazzo, la porta è il numero dell'appartamento.
    - Le porte da 0 a 1023 sono "well-known ports" e sono riservate a servizi standard (es. porta 80 per HTTP, 443 per HTTPS). Per le proprie applicazioni, si usano porte superiori a 1023.

3.  **Socket:** È il "punto finale" di una comunicazione di rete. Un socket è definito da una combinazione di un indirizzo IP e un numero di porta. Immagina due telefoni: per comunicare, entrambi devono avere un numero (IP + porta) e stabilire una chiamata (la connessione).

4.  **Protocollo TCP (Transmission Control Protocol):** È il protocollo più usato per la comunicazione via socket. È **orientato alla connessione** e **affidabile**.
    - **Orientato alla connessione:** Prima di scambiare dati, client e server stabiliscono una connessione stabile (un "handshake").
    - **Affidabile:** Garantisce che tutti i dati inviati arrivino a destinazione, integri e nello stesso ordine in cui sono stati spediti. Se un pacchetto di dati si perde, viene ritrasmesso.

--- IL MODELLO CLIENT-SERVER ---

La comunicazione avviene sempre tra due ruoli distinti:

**1. Il Server:**
   - È un programma **passivo** che si mette in "ascolto" su una porta specifica.
   - Attende che un client si connetta.
   - Una volta stabilita la connessione, può scambiare dati con quel client.
   - **Classi Java Coinvolte:**
     - `java.net.ServerSocket`: Usata dal server per mettersi in ascolto su una porta.
       `ServerSocket serverSocket = new ServerSocket(porta);`
     - `serverSocket.accept()`: È un metodo **bloccante**. Il server si ferma e attende. Quando un client si connette, questo metodo restituisce un oggetto `Socket` che rappresenta la connessione con quel client.

**2. Il Client:**
   - È un programma **attivo** che inizia la comunicazione.
   - Conosce l'indirizzo IP e la porta del server a cui vuole connettersi.
   - Tenta di stabilire una connessione con il server.
   - **Classe Java Coinvolta:**
     - `java.net.Socket`: Usata dal client per connettersi a un server.
       `Socket socket = new Socket("indirizzo_server", porta_server);`

--- COMUNICAZIONE TRAMITE STREAM ---

Una volta che la connessione è stabilita (il server ha accettato la richiesta del client), entrambi ottengono un oggetto `Socket`. Questo `Socket` fornisce due canali di comunicazione, rappresentati come **stream**:

- **`socket.getInputStream()`**: Un `InputStream` per **leggere** i dati inviati dall'altro capo della connessione.
- **`socket.getOutputStream()`**: Un `OutputStream` per **scrivere** (inviare) dati all'altro capo della connessione.

Poiché questi sono stream di byte grezzi, vengono quasi sempre "avvolti" in stream più comodi, come `BufferedReader` e `PrintWriter` per la comunicazione testuale, o `DataInputStream` e `DataOutputStream` per quella binaria.

**Flusso di Esecuzione:**
1.  **Avvia il `Server.java`**. Vedrai il messaggio "Server avviato. In ascolto...". Il programma si fermerà in attesa.
2.  **Avvia il `Client.java`**.
3.  Il client si connetterà al server.
4.  Il server accetterà la connessione.
5.  Il client invierà il suo messaggio.
6.  Il server lo riceverà, lo stamperà e invierà una risposta.
7.  Il client riceverà la risposta e la stamperà.
8.  Entrambi i programmi termineranno.

Questo esempio mostra la comunicazione con un singolo client. Un server reale userebbe i **thread** per gestire più client contemporaneamente (un thread separato per ogni connessione accettata).
