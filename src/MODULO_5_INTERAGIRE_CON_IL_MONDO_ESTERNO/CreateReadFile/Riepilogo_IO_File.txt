RIEPILOGO SULL'I/O (INPUT/OUTPUT) DI FILE IN JAVA

La gestione dell'Input/Output (I/O) su file in Java si è evoluta nel tempo. Esistono principalmente tre "generazioni" di API per lavorare con i file.

--- 1. I/O CLASSICO (`java.io`) - L'APPROCCIO STORICO ---

Questo è l'approccio originale di Java, basato su **stream di byte e di caratteri**.

- **Classe Principale:** `java.io.File`
  - Rappresenta un percorso nel filesystem, ma è una classe considerata obsoleta e goffa. Ha metodi limitati per la manipolazione di file e directory (es. `mkdir()`, `delete()`, `exists()`).

- **Stream di Byte (per dati binari: immagini, audio, ecc.):**
  - `FileInputStream`: Per leggere dati binari da un file.
  - `FileOutputStream`: Per scrivere dati binari su un file.

- **Stream di Caratteri (per file di testo):**
  - `FileReader`: Per leggere caratteri da un file di testo.
  - `FileWriter`: Per scrivere caratteri su un file di testo.

- **Wrapper per l'Efficienza (Buffering):**
  Per migliorare le performance, gli stream di base vengono spesso "avvolti" (wrapped) in classi bufferizzate, che leggono/scrivono dati a "blocchi" (buffer) invece che un byte/carattere alla volta.
  - `BufferedReader`: Aggiunge efficienza e il comodissimo metodo `readLine()` a uno stream di caratteri.
  - `BufferedWriter`: Aggiunge efficienza e il metodo `newLine()` a uno stream di caratteri.
  - `PrintWriter`: Un wrapper ancora più potente che fornisce i metodi `print()` e `println()`, simili a `System.out`.

**Svantaggi dell'I/O Classico:**
- Gestione manuale delle risorse (`close()`), che porta facilmente a resource leak se non si usa un blocco `finally`.
- API della classe `File` poco potente e inconsistente (es. `renameTo()` che a volte fallisce senza un motivo chiaro).
- Gestione degli errori limitata (spesso restituisce `false` invece di lanciare un'eccezione specifica).

--- 2. I/O CON `try-with-resources` (DA JAVA 7) ---

Java 7 ha introdotto il costrutto `try-with-resources`, che ha modernizzato l'uso dell'I/O classico.

**Concetto:**
Qualsiasi risorsa dichiarata tra le parentesi di un `try` (che implementi l'interfaccia `AutoCloseable`, come tutti gli stream) viene **chiusa automaticamente** alla fine del blocco, sia che termini normalmente sia che lanci un'eccezione.

`try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {`
`    String line;`
`    while ((line = reader.readLine()) != null) {`
`        System.out.println(line);`
`    }`
`} catch (IOException e) {`
`    // Gestisci l'eccezione`
`}`
// `reader` è già stato chiuso qui, non serve un blocco `finally`.

Questo costrutto ha risolto il problema principale della gestione manuale delle risorse, rendendo il codice I/O molto più pulito e sicuro.

--- 3. NIO.2 (NEW I/O 2) - L'APPROCCIO MODERNO (DA JAVA 7) ---

NIO.2, introdotto in Java 7 e contenuto nel package `java.nio.file`, è l'API moderna e raccomandata per tutte le operazioni su file e directory.

- **Classi Principali:**
  - `Path`: Sostituisce la vecchia classe `File`. È un oggetto immutabile che rappresenta un percorso nel filesystem in modo più robusto e astratto. Si crea usando la classe factory `Paths` (es. `Paths.get("dir", "file.txt")`).
  - `Files`: Una classe di utilità (`static`) che contiene decine di metodi per operare su `Path` in modo potente e conciso.

**Vantaggi di NIO.2:**
- **API Ricca e Potente:** Fornisce metodi diretti per quasi ogni operazione: `Files.createDirectory()`, `Files.copy()`, `Files.move()`, `Files.delete()`, `Files.size()`, ecc.
- **Migliore Gestione degli Errori:** Lancia eccezioni specifiche e dettagliate (`NoSuchFileException`, `DirectoryNotEmptyException`, ecc.) invece di restituire `false`.
- **Integrazione con le Stream API (da Java 8):** Permette di processare il contenuto di file e directory in modo funzionale e "lazy`.
  - `Files.lines(path)`: Restituisce uno `Stream<String>` per leggere un file di testo riga per riga in modo efficiente.
  - `Files.list(path)`: Restituisce uno `Stream<Path>` per elencare il contenuto di una directory (non ricorsivo).
  - `Files.walk(path)`: Restituisce uno `Stream<Path>` per "camminare" ricorsivamente in un albero di directory.
- **Funzionalità Avanzate:** Include supporto per attributi dei file, link simbolici, `FileVisitor` per attraversamenti complessi e `WatchService` per monitorare le modifiche al filesystem.

**Esempi Comuni con NIO.2:**

- **Leggere tutte le righe di un file piccolo:**
  `List<String> lines = Files.readAllLines(Paths.get("file.txt"));`

- **Scrivere una lista di stringhe su un file:**
  `Files.write(Paths.get("file.txt"), lines);`

- **Copiare un file:**
  `Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);`

--- QUALE APPROCCIO USARE? ---

- **Per tutte le nuove operazioni su file e directory, usa l'API NIO.2 (`Path` e `Files`).** È più potente, sicura e concisa.
- L'I/O classico (`java.io`) rimane importante perché molte librerie e API legacy lo usano ancora. Quando devi usarlo, fallo sempre all'interno di un blocco **`try-with-resources`**.
